import { readdirSync, statSync, readFileSync } from "fs";
import { join, relative } from "path";

interface MenuItem {
	title: string;
	description: string;
	author: string;
	date: string;
	link: string;
}

interface MenuDir {
	name?: string;
	items: MenuItem[];
	subdirs: MenuDir[];
}

const ROOT_DIR = join(process.env.HOME || "", "src/routes");

/**
 * Scan a directory recursively for .mdx files.
 * @param dir Directory to scan for .mdx files
 * @returns Array of .mdx file paths
 */
function scanDir(dir: string): string[] {
	let files: string[] = [];
	for (const entry of readdirSync(dir)) {
		const fullPath = join(dir, entry);
		const stats = statSync(fullPath);
		if (stats.isDirectory()) {
			files = files.concat(scanDir(fullPath));
		} else if (entry.endsWith("index.mdx")) {
			files.push(fullPath);
		}
	}
	return files;
}

/**
 * Parse frontmatter from a markdown file.
 * @param content Content of the markdown file
 * @returns Parsed frontmatter as key-value pairs
 */
function parseFrontmatter(content: string): Record<string, string> {
	const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
	if (!match) return {};
	const yaml = match[1];
	const data: Record<string, string> = {};
	yaml.split("\n").forEach(line => {
		const [key, ...rest] = line.split(":");
		if (key && rest.length) {
			data[key.trim()] = rest.join(":").trim();
		}
	});
	return data;
}

/**
 * Add an item to the menu tree.
 * @param tree The menu directory tree
 * @param pathParts Parts of the file path
 * @param meta Metadata from the frontmatter
 * @param relativePath Relative path to the file
 */
function addToTree(tree: MenuDir, pathParts: string[], meta: Record<string, string>, relativePath: string) {
	if (pathParts.length === 1) {
		tree.items.push({
			title: meta.title || "Untitled",
			description: meta.description || "",
			author: meta.author || "",
			date: meta.date || "",
			link: relativePath
		});
	} else {
		const dirName = pathParts[0];
		let sub = tree.subdirs.find(s => s.name === dirName);
		if (!sub) {
			sub = { name: dirName, items: [], subdirs: [] };
			tree.subdirs.push(sub);
		}
		addToTree(sub, pathParts.slice(1), meta, relativePath);
	}
}

/**
 * Print the menu tree to the console.
 * @param tree The menu directory tree
 * @param depth Current depth in the tree for formatting
 */
function printTree(tree: MenuDir, depth = 0) {
	const headingPrefix = "#".repeat(depth + 1);
	if (depth === 0) {
		console.log(`${headingPrefix} Root\n`);
	} else {
		console.log(`${headingPrefix} ${tree.name}\n`);
	}

	for (const item of tree.items) {
		console.log(`- [${item.title}](${item.link})`);
		if (item.description) console.log(`- ${item.description}`);
		if (item.author) console.log(`- ${item.author}`);
		if (item.date) console.log(`- ${item.date}`);
		console.log("");
	}

	for (const sub of tree.subdirs.sort((a, b) => (a.name || "").localeCompare(b.name || ""))) {
		printTree(sub, depth + 1);
	}
}

const files = scanDir(ROOT_DIR);
const tree: MenuDir = { items: [], subdirs: [] };

for (const file of files) {
	const rel = relative(ROOT_DIR, file).replace(/\\\\?/g, "/");
	const parts = rel.split("/");
	const content = readFileSync(file, "utf-8");
	const meta = parseFrontmatter(content);

	if (meta.showInHeader === "true" && meta.mdxLayout === "true") {
		addToTree(tree, parts, meta, rel);
	}
}

console.log("[//]: <> (------------------------------------------------------------------------)");
console.log("[//]: <> (This file is auto-generated by the menu script. Do not edit it manually.)");
console.log("[//]: <> (------------------------------------------------------------------------)\n");
printTree(tree);
